ifndef::imagesdir[:imagesdir: ../images]

[[section-context-and-scope]]
== Context and Scope

ifdef::arc42help[]
[role="arc42help"]
****
.Contents
Context and scope - as the name suggests - delimits your system (i.e. your scope) from all its communication partners
(neighboring systems and users, i.e. the context of your system). It thereby specifies the external interfaces.

If necessary, differentiate the business context (domain specific inputs and outputs) from the technical context (channels, protocols, hardware).

.Motivation
The domain interfaces and technical interfaces to communication partners are among your system's most critical aspects. Make sure that you completely understand them.

.Form
Various options:

* Context diagrams
* Lists of communication partners and their interfaces.

.Further Information

See https://docs.arc42.org/section-3/[Context and Scope] in the arc42 documentation.

****
endif::arc42help[]

=== Business Context

ifdef::arc42help[]
[role="arc42help"]
****
.Contents
Specification of *all* communication partners (users, IT-systems, ...) with explanations of domain specific inputs and outputs or interfaces.
Optionally you can add domain specific formats or communication protocols.

.Motivation
All stakeholders should understand which data are exchanged with the environment of the system.

.Form
All kinds of diagrams that show the system as a black box and specify the domain interfaces to communication partners.

Alternatively (or additionally) you can use a table.
The title of the table is the name of your system, the three columns contain the name of the communication partner, the inputs, and the outputs.

****
endif::arc42help[]

[plantuml,"C4 Diagram - Business context", png, align="center", title="Overall view of the business context"]
----
include::./diagrams/S3_C4_Business_Context_Diagram.puml[]
----
The business model diagram represents how the player interacts with the system of the WiChat application, which will communicate with the WikiData API using the HTTP protocol and MongoDB Query Languague (MQL) queries to retrieve the information. The data retrieved by the API will be used to generate the questions that the player must answer, in this case, an image will be retrieved, and the player must select the option that best fits what is shown in the picture. The player can also ask for help from the LLM Chat, which will use the information from the WikiData API to provide clues about the image.
A simple example of the functioning of the system is the following: the player logs in and starts a game. The system retrieves data from the WikiData API and generates the image and the possible answers (for example, an image of the Eiffel Tower, and four cities of Europe, like Madrid, Rome, London and Paris). The player may ask for help to the LLM Chat if he/she is not sure about the answer, and the AI will use the information from the WikiData API to provide clues about the image. The player can then select the correct answer, and the system will inform if it is correct or not.

=== Technical Context

ifdef::arc42help[]
[role="arc42help"]
****
.Contents
Technical interfaces (channels and transmission media) linking your system to its environment. In addition a mapping of domain specific input/output to the channels, i.e. an explanation which I/O uses which channel.

.Motivation
Many stakeholders make architectural decision based on the technical interfaces between the system and its context. Especially infrastructure or hardware designers decide these technical interfaces.

.Form
E.g. UML deployment diagram describing channels to neighboring systems,
together with a mapping table showing the relationships between channels and input/output.

****
endif::arc42help[]

[plantuml, "C4 Diagram - Technical context diagram", png, align="center", title="Overall view of the technical context"]
----
include::./diagrams/S3_C4_Technical_Context_Diagram.puml[]
----
The system will be deployed in a single server (using **Docker**) containing all the functionalities separated in different modules:

* **Wichat Application Proxy: **
When interacting with the server, a <TO BE DEFINED> proxy will be tasked with redirecting the queries to the petitions to the Wichat application client, which will also be deployed on a Azure web server.

* **Wichat Application Client: **
This client will be served to the user and communicates with the API through HTTPS calls and exchanges information through JSON objects. The client (Front-End of the application) will be developed in React (+ JavaScript), and it is deployed via a Azure server.

* **Wichat REST API:**
The Wichat REST API will be run as a .jar file on the server and connect to a database running on a MongoDB docker container. The connection layer between the <TO BE DEFINED> API and the database will be <TO BE DEFINED>.

* **Wichat Application Database:**
The questions and answers generated by the Question Generator module will be stored in the database, implemented using Node.js and MongoDB as the DBMS. The connection layer will use Mongoose.
* **Question generator:**
The Question Generator will also use the WikiData REST API to retrieve information to generate questions. It  will generate the questions by connecting to the WikiData REST API through HTTPS calls and passing a MQL query to retrieve the data that will later be used in the question generation. The module is implemented using Node.js and utilizes Axios  for making HTTP requests.
